// Code generated by protoc-gen-go. DO NOT EDIT.
// source: netinst.proto

package config

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type ZNetworkInstType int32

const (
	ZNetworkInstType_ZNetInstFirst       ZNetworkInstType = 0
	ZNetworkInstType_ZnetInstSwitch      ZNetworkInstType = 1
	ZNetworkInstType_ZnetInstLocal       ZNetworkInstType = 2
	ZNetworkInstType_ZnetInstCloud       ZNetworkInstType = 3
	ZNetworkInstType_ZnetInstMesh        ZNetworkInstType = 4
	ZNetworkInstType_ZnetInstHoneyPot    ZNetworkInstType = 5
	ZNetworkInstType_ZnetInstTransparent ZNetworkInstType = 6
	ZNetworkInstType_ZNetInstLast        ZNetworkInstType = 255
)

var ZNetworkInstType_name = map[int32]string{
	0:   "ZNetInstFirst",
	1:   "ZnetInstSwitch",
	2:   "ZnetInstLocal",
	3:   "ZnetInstCloud",
	4:   "ZnetInstMesh",
	5:   "ZnetInstHoneyPot",
	6:   "ZnetInstTransparent",
	255: "ZNetInstLast",
}

var ZNetworkInstType_value = map[string]int32{
	"ZNetInstFirst":       0,
	"ZnetInstSwitch":      1,
	"ZnetInstLocal":       2,
	"ZnetInstCloud":       3,
	"ZnetInstMesh":        4,
	"ZnetInstHoneyPot":    5,
	"ZnetInstTransparent": 6,
	"ZNetInstLast":        255,
}

func (x ZNetworkInstType) String() string {
	return proto.EnumName(ZNetworkInstType_name, int32(x))
}

func (ZNetworkInstType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_5d61ed8cf2f4078e, []int{0}
}

type AddressType int32

const (
	AddressType_First      AddressType = 0
	AddressType_IPV4       AddressType = 1
	AddressType_IPV6       AddressType = 2
	AddressType_CryptoIPV4 AddressType = 3
	AddressType_CryptoIPV6 AddressType = 4
	AddressType_Last       AddressType = 255
)

var AddressType_name = map[int32]string{
	0:   "First",
	1:   "IPV4",
	2:   "IPV6",
	3:   "CryptoIPV4",
	4:   "CryptoIPV6",
	255: "Last",
}

var AddressType_value = map[string]int32{
	"First":      0,
	"IPV4":       1,
	"IPV6":       2,
	"CryptoIPV4": 3,
	"CryptoIPV6": 4,
	"Last":       255,
}

func (x AddressType) String() string {
	return proto.EnumName(AddressType_name, int32(x))
}

func (AddressType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_5d61ed8cf2f4078e, []int{1}
}

type ZNetworkOpaqueConfigType int32

const (
	ZNetworkOpaqueConfigType_ZNetOConfigVPN  ZNetworkOpaqueConfigType = 0
	ZNetworkOpaqueConfigType_ZNetOConfigLisp ZNetworkOpaqueConfigType = 1
)

var ZNetworkOpaqueConfigType_name = map[int32]string{
	0: "ZNetOConfigVPN",
	1: "ZNetOConfigLisp",
}

var ZNetworkOpaqueConfigType_value = map[string]int32{
	"ZNetOConfigVPN":  0,
	"ZNetOConfigLisp": 1,
}

func (x ZNetworkOpaqueConfigType) String() string {
	return proto.EnumName(ZNetworkOpaqueConfigType_name, int32(x))
}

func (ZNetworkOpaqueConfigType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_5d61ed8cf2f4078e, []int{2}
}

type ZcServiceType int32

const (
	ZcServiceType_zcloudInvalidSrv ZcServiceType = 0
	// mapping service for zededa overlay service
	ZcServiceType_mapServer ZcServiceType = 1
	// if device has support feature enabled, this is cloud service from
	// device can be reached
	ZcServiceType_supportServer ZcServiceType = 2
)

var ZcServiceType_name = map[int32]string{
	0: "zcloudInvalidSrv",
	1: "mapServer",
	2: "supportServer",
}

var ZcServiceType_value = map[string]int32{
	"zcloudInvalidSrv": 0,
	"mapServer":        1,
	"supportServer":    2,
}

func (x ZcServiceType) String() string {
	return proto.EnumName(ZcServiceType_name, int32(x))
}

func (ZcServiceType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_5d61ed8cf2f4078e, []int{3}
}

// Network Instance Opaque config. In future we might add more fields here
// but idea is here. This is service specific configuration.
type NetworkInstanceOpaqueConfig struct {
	Oconfig              string                     `protobuf:"bytes,1,opt,name=oconfig,proto3" json:"oconfig,omitempty"`
	LispConfig           *NetworkInstanceLispConfig `protobuf:"bytes,2,opt,name=lispConfig,proto3" json:"lispConfig,omitempty"`
	Type                 ZNetworkOpaqueConfigType   `protobuf:"varint,3,opt,name=type,proto3,enum=ZNetworkOpaqueConfigType" json:"type,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                   `json:"-"`
	XXX_unrecognized     []byte                     `json:"-"`
	XXX_sizecache        int32                      `json:"-"`
}

func (m *NetworkInstanceOpaqueConfig) Reset()         { *m = NetworkInstanceOpaqueConfig{} }
func (m *NetworkInstanceOpaqueConfig) String() string { return proto.CompactTextString(m) }
func (*NetworkInstanceOpaqueConfig) ProtoMessage()    {}
func (*NetworkInstanceOpaqueConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_5d61ed8cf2f4078e, []int{0}
}

func (m *NetworkInstanceOpaqueConfig) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_NetworkInstanceOpaqueConfig.Unmarshal(m, b)
}
func (m *NetworkInstanceOpaqueConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_NetworkInstanceOpaqueConfig.Marshal(b, m, deterministic)
}
func (m *NetworkInstanceOpaqueConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NetworkInstanceOpaqueConfig.Merge(m, src)
}
func (m *NetworkInstanceOpaqueConfig) XXX_Size() int {
	return xxx_messageInfo_NetworkInstanceOpaqueConfig.Size(m)
}
func (m *NetworkInstanceOpaqueConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_NetworkInstanceOpaqueConfig.DiscardUnknown(m)
}

var xxx_messageInfo_NetworkInstanceOpaqueConfig proto.InternalMessageInfo

func (m *NetworkInstanceOpaqueConfig) GetOconfig() string {
	if m != nil {
		return m.Oconfig
	}
	return ""
}

func (m *NetworkInstanceOpaqueConfig) GetLispConfig() *NetworkInstanceLispConfig {
	if m != nil {
		return m.LispConfig
	}
	return nil
}

func (m *NetworkInstanceOpaqueConfig) GetType() ZNetworkOpaqueConfigType {
	if m != nil {
		return m.Type
	}
	return ZNetworkOpaqueConfigType_ZNetOConfigVPN
}

// This is way to tell the device if there is service in cloud somewhere,
// what type it is how to access it
type ZcServicePoint struct {
	ZsType               ZcServiceType `protobuf:"varint,3,opt,name=zsType,proto3,enum=ZcServiceType" json:"zsType,omitempty"`
	NameOrIp             string        `protobuf:"bytes,1,opt,name=NameOrIp,proto3" json:"NameOrIp,omitempty"`
	Credential           string        `protobuf:"bytes,2,opt,name=Credential,proto3" json:"Credential,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *ZcServicePoint) Reset()         { *m = ZcServicePoint{} }
func (m *ZcServicePoint) String() string { return proto.CompactTextString(m) }
func (*ZcServicePoint) ProtoMessage()    {}
func (*ZcServicePoint) Descriptor() ([]byte, []int) {
	return fileDescriptor_5d61ed8cf2f4078e, []int{1}
}

func (m *ZcServicePoint) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ZcServicePoint.Unmarshal(m, b)
}
func (m *ZcServicePoint) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ZcServicePoint.Marshal(b, m, deterministic)
}
func (m *ZcServicePoint) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ZcServicePoint.Merge(m, src)
}
func (m *ZcServicePoint) XXX_Size() int {
	return xxx_messageInfo_ZcServicePoint.Size(m)
}
func (m *ZcServicePoint) XXX_DiscardUnknown() {
	xxx_messageInfo_ZcServicePoint.DiscardUnknown(m)
}

var xxx_messageInfo_ZcServicePoint proto.InternalMessageInfo

func (m *ZcServicePoint) GetZsType() ZcServiceType {
	if m != nil {
		return m.ZsType
	}
	return ZcServiceType_zcloudInvalidSrv
}

func (m *ZcServicePoint) GetNameOrIp() string {
	if m != nil {
		return m.NameOrIp
	}
	return ""
}

func (m *ZcServicePoint) GetCredential() string {
	if m != nil {
		return m.Credential
	}
	return ""
}

// Lisp NetworkInstance config
type NetworkInstanceLispConfig struct {
	LispMSs             []*ZcServicePoint `protobuf:"bytes,1,rep,name=LispMSs,proto3" json:"LispMSs,omitempty"`
	LispInstanceId      uint32            `protobuf:"varint,2,opt,name=LispInstanceId,proto3" json:"LispInstanceId,omitempty"`
	Allocate            bool              `protobuf:"varint,3,opt,name=allocate,proto3" json:"allocate,omitempty"`
	Exportprivate       bool              `protobuf:"varint,4,opt,name=exportprivate,proto3" json:"exportprivate,omitempty"`
	Allocationprefix    []byte            `protobuf:"bytes,5,opt,name=allocationprefix,proto3" json:"allocationprefix,omitempty"`
	Allocationprefixlen uint32            `protobuf:"varint,6,opt,name=allocationprefixlen,proto3" json:"allocationprefixlen,omitempty"`
	// various configuration to dataPlane, lispers.net vs Zededa
	Experimental         bool     `protobuf:"varint,20,opt,name=experimental,proto3" json:"experimental,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NetworkInstanceLispConfig) Reset()         { *m = NetworkInstanceLispConfig{} }
func (m *NetworkInstanceLispConfig) String() string { return proto.CompactTextString(m) }
func (*NetworkInstanceLispConfig) ProtoMessage()    {}
func (*NetworkInstanceLispConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_5d61ed8cf2f4078e, []int{2}
}

func (m *NetworkInstanceLispConfig) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_NetworkInstanceLispConfig.Unmarshal(m, b)
}
func (m *NetworkInstanceLispConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_NetworkInstanceLispConfig.Marshal(b, m, deterministic)
}
func (m *NetworkInstanceLispConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NetworkInstanceLispConfig.Merge(m, src)
}
func (m *NetworkInstanceLispConfig) XXX_Size() int {
	return xxx_messageInfo_NetworkInstanceLispConfig.Size(m)
}
func (m *NetworkInstanceLispConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_NetworkInstanceLispConfig.DiscardUnknown(m)
}

var xxx_messageInfo_NetworkInstanceLispConfig proto.InternalMessageInfo

func (m *NetworkInstanceLispConfig) GetLispMSs() []*ZcServicePoint {
	if m != nil {
		return m.LispMSs
	}
	return nil
}

func (m *NetworkInstanceLispConfig) GetLispInstanceId() uint32 {
	if m != nil {
		return m.LispInstanceId
	}
	return 0
}

func (m *NetworkInstanceLispConfig) GetAllocate() bool {
	if m != nil {
		return m.Allocate
	}
	return false
}

func (m *NetworkInstanceLispConfig) GetExportprivate() bool {
	if m != nil {
		return m.Exportprivate
	}
	return false
}

func (m *NetworkInstanceLispConfig) GetAllocationprefix() []byte {
	if m != nil {
		return m.Allocationprefix
	}
	return nil
}

func (m *NetworkInstanceLispConfig) GetAllocationprefixlen() uint32 {
	if m != nil {
		return m.Allocationprefixlen
	}
	return 0
}

func (m *NetworkInstanceLispConfig) GetExperimental() bool {
	if m != nil {
		return m.Experimental
	}
	return false
}

type NetworkInstanceConfig struct {
	Uuidandversion *UUIDandVersion `protobuf:"bytes,1,opt,name=uuidandversion,proto3" json:"uuidandversion,omitempty"`
	Displayname    string          `protobuf:"bytes,2,opt,name=displayname,proto3" json:"displayname,omitempty"`
	// instType - Type of network instance ( local, bridge etc )
	InstType ZNetworkInstType `protobuf:"varint,4,opt,name=instType,proto3,enum=ZNetworkInstType" json:"instType,omitempty"`
	// activate
	//  - True by default. If set to false ( inactivate), the network instance
	//    configuration is downloaded to the device, but the network instance
	//    itself is not created on the device.
	Activate bool `protobuf:"varint,5,opt,name=activate,proto3" json:"activate,omitempty"`
	// port - Only a single port is supported.
	//    This is used as the external connection for the network instance.
	//    This can be a physical (eth0 ) or logical port (vlan 0).
	//    The port name comes from DeviceConfig ( When it is supported in future).
	//    If the user needs multiple physical ports, Device config should be
	//    used to create a label for multiple physical ports.
	Port *Adapter `protobuf:"bytes,20,opt,name=port,proto3" json:"port,omitempty"`
	// cfg - Used to pass some feature-specific configuration to the
	//       network instance. For Ex: Lisp, StriongSwan etc
	Cfg *NetworkInstanceOpaqueConfig `protobuf:"bytes,30,opt,name=cfg,proto3" json:"cfg,omitempty"`
	// type of ipSpec
	IpType AddressType `protobuf:"varint,39,opt,name=ipType,proto3,enum=AddressType" json:"ipType,omitempty"`
	// network ip specification
	Ip *Ipspec `protobuf:"bytes,40,opt,name=ip,proto3" json:"ip,omitempty"`
	// static DNS entry, if we are running DNS/DHCP service
	Dns                  []*ZnetStaticDNSEntry `protobuf:"bytes,41,rep,name=dns,proto3" json:"dns,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *NetworkInstanceConfig) Reset()         { *m = NetworkInstanceConfig{} }
func (m *NetworkInstanceConfig) String() string { return proto.CompactTextString(m) }
func (*NetworkInstanceConfig) ProtoMessage()    {}
func (*NetworkInstanceConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_5d61ed8cf2f4078e, []int{3}
}

func (m *NetworkInstanceConfig) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_NetworkInstanceConfig.Unmarshal(m, b)
}
func (m *NetworkInstanceConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_NetworkInstanceConfig.Marshal(b, m, deterministic)
}
func (m *NetworkInstanceConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NetworkInstanceConfig.Merge(m, src)
}
func (m *NetworkInstanceConfig) XXX_Size() int {
	return xxx_messageInfo_NetworkInstanceConfig.Size(m)
}
func (m *NetworkInstanceConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_NetworkInstanceConfig.DiscardUnknown(m)
}

var xxx_messageInfo_NetworkInstanceConfig proto.InternalMessageInfo

func (m *NetworkInstanceConfig) GetUuidandversion() *UUIDandVersion {
	if m != nil {
		return m.Uuidandversion
	}
	return nil
}

func (m *NetworkInstanceConfig) GetDisplayname() string {
	if m != nil {
		return m.Displayname
	}
	return ""
}

func (m *NetworkInstanceConfig) GetInstType() ZNetworkInstType {
	if m != nil {
		return m.InstType
	}
	return ZNetworkInstType_ZNetInstFirst
}

func (m *NetworkInstanceConfig) GetActivate() bool {
	if m != nil {
		return m.Activate
	}
	return false
}

func (m *NetworkInstanceConfig) GetPort() *Adapter {
	if m != nil {
		return m.Port
	}
	return nil
}

func (m *NetworkInstanceConfig) GetCfg() *NetworkInstanceOpaqueConfig {
	if m != nil {
		return m.Cfg
	}
	return nil
}

func (m *NetworkInstanceConfig) GetIpType() AddressType {
	if m != nil {
		return m.IpType
	}
	return AddressType_First
}

func (m *NetworkInstanceConfig) GetIp() *Ipspec {
	if m != nil {
		return m.Ip
	}
	return nil
}

func (m *NetworkInstanceConfig) GetDns() []*ZnetStaticDNSEntry {
	if m != nil {
		return m.Dns
	}
	return nil
}

func init() {
	proto.RegisterEnum("ZNetworkInstType", ZNetworkInstType_name, ZNetworkInstType_value)
	proto.RegisterEnum("AddressType", AddressType_name, AddressType_value)
	proto.RegisterEnum("ZNetworkOpaqueConfigType", ZNetworkOpaqueConfigType_name, ZNetworkOpaqueConfigType_value)
	proto.RegisterEnum("ZcServiceType", ZcServiceType_name, ZcServiceType_value)
	proto.RegisterType((*NetworkInstanceOpaqueConfig)(nil), "NetworkInstanceOpaqueConfig")
	proto.RegisterType((*ZcServicePoint)(nil), "ZcServicePoint")
	proto.RegisterType((*NetworkInstanceLispConfig)(nil), "NetworkInstanceLispConfig")
	proto.RegisterType((*NetworkInstanceConfig)(nil), "NetworkInstanceConfig")
}

func init() { proto.RegisterFile("netinst.proto", fileDescriptor_5d61ed8cf2f4078e) }

var fileDescriptor_5d61ed8cf2f4078e = []byte{
	// 797 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x7c, 0x94, 0x6f, 0x6f, 0xdb, 0x36,
	0x10, 0xc6, 0x23, 0xdb, 0x71, 0xec, 0xf3, 0x9f, 0x30, 0x4c, 0x87, 0xaa, 0x59, 0xd1, 0x19, 0x5e,
	0xd7, 0xb9, 0x01, 0x2a, 0x0f, 0xd9, 0xd0, 0x01, 0x7b, 0xd7, 0xa5, 0xeb, 0x66, 0x20, 0x75, 0x02,
	0x39, 0xcd, 0x80, 0xbc, 0x63, 0xa5, 0x4b, 0x42, 0x54, 0x26, 0x39, 0x92, 0x76, 0xe3, 0x7c, 0x9c,
	0x7d, 0x84, 0xed, 0x93, 0xed, 0x13, 0x6c, 0x20, 0x25, 0x79, 0xb6, 0xb7, 0xf4, 0x9d, 0xee, 0x77,
	0x8f, 0x4e, 0x77, 0x8f, 0x8e, 0x84, 0x8e, 0x40, 0xcb, 0x85, 0xb1, 0x91, 0xd2, 0xd2, 0xca, 0x83,
	0xdd, 0x14, 0xe7, 0x89, 0x9c, 0x4e, 0xa5, 0x28, 0x40, 0x5b, 0xa0, 0x4d, 0xa6, 0x45, 0xd4, 0xff,
	0x3d, 0x80, 0xcf, 0xc7, 0x68, 0x3f, 0x4a, 0xfd, 0x61, 0x24, 0x8c, 0x65, 0x22, 0xc1, 0x53, 0xc5,
	0x7e, 0x9b, 0xe1, 0xb1, 0x14, 0x57, 0xfc, 0x9a, 0x86, 0xb0, 0x23, 0x13, 0xff, 0x18, 0x06, 0xbd,
	0x60, 0xd0, 0x8c, 0xcb, 0x90, 0xfe, 0x00, 0x90, 0x71, 0xa3, 0x72, 0x5d, 0x58, 0xe9, 0x05, 0x83,
	0xd6, 0xd1, 0x41, 0xb4, 0x51, 0xeb, 0x64, 0xa9, 0x88, 0x57, 0xd4, 0xf4, 0x05, 0xd4, 0xec, 0x42,
	0x61, 0x58, 0xed, 0x05, 0x83, 0xee, 0xd1, 0xa3, 0xe8, 0xb2, 0x78, 0x6d, 0xf5, 0xd3, 0xe7, 0x0b,
	0x85, 0xb1, 0x97, 0xf5, 0x2d, 0x74, 0x2f, 0x93, 0x09, 0xea, 0x39, 0x4f, 0xf0, 0x4c, 0x72, 0x61,
	0xe9, 0x33, 0xa8, 0xdf, 0x99, 0xf3, 0x7f, 0x4b, 0x74, 0xa3, 0xa5, 0xc0, 0xbf, 0x57, 0x64, 0xe9,
	0x01, 0x34, 0xc6, 0x6c, 0x8a, 0xa7, 0x7a, 0xa4, 0x8a, 0xfe, 0x97, 0x31, 0x7d, 0x02, 0x70, 0xac,
	0x31, 0x45, 0x61, 0x39, 0xcb, 0xfc, 0x00, 0xcd, 0x78, 0x85, 0xf4, 0xff, 0xa8, 0xc0, 0xa3, 0x7b,
	0xc7, 0xa1, 0xcf, 0x61, 0xc7, 0x45, 0x6f, 0x27, 0x26, 0x0c, 0x7a, 0xd5, 0x41, 0xeb, 0x68, 0x37,
	0x5a, 0xef, 0x31, 0x2e, 0xf3, 0xf4, 0x19, 0x74, 0xdd, 0x63, 0x59, 0x64, 0x94, 0xfa, 0x8f, 0x75,
	0xe2, 0x0d, 0xea, 0x9a, 0x65, 0x59, 0x26, 0x13, 0x66, 0xf3, 0xb1, 0x1a, 0xf1, 0x32, 0xa6, 0x4f,
	0xa1, 0x83, 0xb7, 0x4a, 0x6a, 0xab, 0x34, 0x9f, 0x3b, 0x41, 0xcd, 0x0b, 0xd6, 0x21, 0x3d, 0x04,
	0x52, 0xbc, 0xc1, 0xa5, 0x50, 0x1a, 0xaf, 0xf8, 0x6d, 0xb8, 0xdd, 0x0b, 0x06, 0xed, 0xf8, 0x3f,
	0x9c, 0x7e, 0x03, 0xfb, 0x9b, 0x2c, 0x43, 0x11, 0xd6, 0x7d, 0x6b, 0xff, 0x97, 0xa2, 0x7d, 0x68,
	0xe3, 0xad, 0x42, 0xcd, 0xa7, 0x28, 0x2c, 0xcb, 0xc2, 0x07, 0xbe, 0x85, 0x35, 0xd6, 0xff, 0xab,
	0x02, 0x9f, 0x6d, 0x98, 0x56, 0x18, 0xf6, 0x3d, 0x74, 0x67, 0x33, 0x9e, 0x32, 0x91, 0xce, 0x51,
	0x1b, 0x2e, 0x85, 0xff, 0x21, 0xce, 0xb7, 0x77, 0xef, 0x46, 0xaf, 0x99, 0x48, 0x2f, 0x72, 0x1c,
	0x6f, 0xc8, 0x68, 0x0f, 0x5a, 0x29, 0x37, 0x2a, 0x63, 0x0b, 0xc1, 0xa6, 0x58, 0xfc, 0xa8, 0x55,
	0x44, 0x5f, 0x40, 0xc3, 0x6d, 0xbc, 0xdf, 0x87, 0x9a, 0xdf, 0x87, 0xbd, 0xe5, 0x4a, 0x8d, 0x8a,
	0x44, 0xbc, 0x94, 0x78, 0x9f, 0x13, 0x9b, 0xdb, 0xb8, 0x5d, 0xf8, 0x5c, 0xc4, 0xf4, 0x31, 0xd4,
	0x9c, 0xa1, 0x7e, 0xb6, 0xd6, 0x51, 0x23, 0x7a, 0x95, 0x32, 0x65, 0x51, 0xc7, 0x9e, 0xd2, 0x08,
	0xaa, 0xc9, 0xd5, 0x75, 0xf8, 0xc4, 0x27, 0x1f, 0x47, 0x9f, 0x38, 0x38, 0xb1, 0x13, 0xd2, 0xa7,
	0x50, 0xe7, 0xca, 0xb7, 0xf5, 0xb5, 0x6f, 0xab, 0x1d, 0xbd, 0x4a, 0x53, 0x8d, 0xc6, 0xe4, 0x4b,
	0x9a, 0xe7, 0xe8, 0x43, 0xa8, 0x70, 0x15, 0x0e, 0x7c, 0xd1, 0x9d, 0x88, 0x2b, 0xa3, 0x30, 0x89,
	0x2b, 0x5c, 0xd1, 0xaf, 0xa0, 0x9a, 0x0a, 0x13, 0x3e, 0xf7, 0xfb, 0xb5, 0x1f, 0x5d, 0x0a, 0xb4,
	0x13, 0xcb, 0x2c, 0x4f, 0x5e, 0x8f, 0x27, 0x3f, 0x09, 0xab, 0x17, 0xb1, 0xcb, 0x1f, 0xfe, 0x19,
	0x00, 0xd9, 0x1c, 0x97, 0xee, 0x41, 0xc7, 0x31, 0x17, 0xbf, 0xe1, 0xda, 0x58, 0xb2, 0x45, 0x29,
	0x74, 0x5d, 0x09, 0x87, 0x26, 0x1f, 0xb9, 0x4d, 0x6e, 0x48, 0xe0, 0x65, 0x05, 0x3b, 0x91, 0x09,
	0xcb, 0x48, 0x65, 0x15, 0x1d, 0x67, 0x72, 0x96, 0x92, 0x2a, 0x25, 0xd0, 0x2e, 0xd1, 0x5b, 0x34,
	0x37, 0xa4, 0x46, 0x1f, 0x00, 0x29, 0xc9, 0x2f, 0x52, 0xe0, 0xe2, 0x4c, 0x5a, 0xb2, 0x4d, 0x1f,
	0xc2, 0x7e, 0x49, 0xcf, 0x35, 0x13, 0x46, 0x31, 0x8d, 0xc2, 0x92, 0x3a, 0xdd, 0x83, 0x76, 0xd9,
	0xcd, 0x09, 0x33, 0x96, 0xfc, 0x1d, 0x1c, 0xfe, 0x0a, 0xad, 0x15, 0x33, 0x68, 0x13, 0xb6, 0xcb,
	0x3e, 0x1b, 0x50, 0x1b, 0x9d, 0x5d, 0x7c, 0x47, 0x82, 0xe2, 0xe9, 0x25, 0xa9, 0xd0, 0xae, 0x3b,
	0xac, 0x0b, 0x65, 0xa5, 0xcf, 0x54, 0xd7, 0xe2, 0x97, 0xa4, 0x46, 0x9b, 0x50, 0x2b, 0x0b, 0x1f,
	0x43, 0x78, 0xdf, 0x7d, 0xe2, 0x2d, 0x18, 0xa3, 0x3d, 0xcd, 0xd1, 0xc5, 0xd9, 0x98, 0x6c, 0xd1,
	0x7d, 0xd8, 0x5d, 0x61, 0xee, 0x4c, 0x92, 0xe0, 0xf0, 0x67, 0xe8, 0xac, 0xdd, 0x28, 0x6e, 0xe0,
	0xbb, 0xc4, 0xd9, 0x31, 0x12, 0x73, 0x96, 0xf1, 0x74, 0xa2, 0xe7, 0x64, 0x8b, 0x76, 0xa0, 0x39,
	0x65, 0xca, 0xe9, 0x50, 0xe7, 0x6e, 0x9a, 0x99, 0x72, 0xab, 0x52, 0xa0, 0xca, 0x8f, 0x6f, 0xe0,
	0x8b, 0x44, 0x4e, 0xa3, 0x3b, 0x4c, 0x31, 0x65, 0x91, 0xaf, 0x10, 0xcd, 0x4c, 0x5e, 0x38, 0xbf,
	0x83, 0x2f, 0xbf, 0xbc, 0xe6, 0xf6, 0x66, 0xf6, 0x3e, 0x4a, 0xe4, 0x74, 0x98, 0xeb, 0x86, 0x38,
	0xc7, 0xa1, 0x49, 0x3f, 0x0c, 0xaf, 0xe5, 0x30, 0xbf, 0x6e, 0xdf, 0xd7, 0xbd, 0xf6, 0xdb, 0x7f,
	0x02, 0x00, 0x00, 0xff, 0xff, 0xdf, 0x59, 0x66, 0x61, 0xdf, 0x05, 0x00, 0x00,
}
